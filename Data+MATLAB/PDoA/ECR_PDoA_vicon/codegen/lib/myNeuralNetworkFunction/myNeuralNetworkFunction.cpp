//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: myNeuralNetworkFunction.cpp
//
// MATLAB Coder version            : 5.0
// C/C++ source code generated on  : 13-May-2020 20:31:24
//

// Include Files
#include "myNeuralNetworkFunction.h"
#include <cmath>

// Function Definitions

//
// MYNEURALNETWORKFUNCTION neural network simulation function.
//
//  Auto-generated by MATLAB, 13-May-2020 20:25:21.
//
//  [y1] = myNeuralNetworkFunction(x1) takes these arguments:
//    x = Qx4 matrix, input #1
//  and returns:
//    y = Qx3 matrix, output #1
//  where Q is the number of samples.
// Arguments    : double x1
//                double b_y1[3]
// Return Type  : void
//
void myNeuralNetworkFunction(double x1, double b_y1[3])
{
  double xp1_idx_0;
  double xp1_idx_1;
  double xp1_idx_2;
  double xp1_idx_3;
  double b[3];
  int k;
  double b_b[5];
  static const double a[5] = { -0.86553589611854, -0.8255850950186252,
    -0.76154563759084171, 1.1430083462404215, -0.76684001462973184 };

  static const double b_a[20] = { 0.32117120541143468, 0.29439209063251354,
    0.02245578598181024, 1.1112790991270596, -0.024986184568630214,
    0.16334540561950975, 0.16466440127232432, 0.21179949463406941,
    0.32147062046894909, 0.23033552096385512, 0.110664358516103,
    0.060823316898761547, -0.083053996858257081, -0.72601682539100765,
    -0.12838757564883496, 0.44629900722320393, 0.42360884707571284,
    0.32639896070309121, -1.0878052540614334, 0.31097355025288925 };

  static const double dv[3] = { 0.533787165877804, 0.788527964418997,
    2.25106301047751 };

  static const double c_a[15] = { 12.468082696860492, 5.6949516615134392,
    -44.377405709708349, -20.24494849476843, -24.7296522399689,
    68.964088589300374, 17.27002357312125, 101.46152686325402,
    -155.08796235732842, -0.46000877447950755, 1.4092547253193284,
    0.33439147297792315, -9.6143961998812735, -77.30347531622003,
    129.54361923944225 };

  static const double dv1[3] = { -1.82517310309568, 0.576613863304083,
    -0.470200245018933 };

  //  ===== NEURAL NETWORK CONSTANTS =====
  //  Input 1
  //  Layer 1
  //  Layer 2
  //  Output 1
  //  ===== SIMULATION ========
  //  Dimensions
  //  samples
  //  Input 1
  //  ===== MODULE FUNCTIONS ========
  //  Map Minimum and Maximum Input Processing Function
  xp1_idx_0 = (x1 - -166881.0) * 6.4553820133691E-6 + -1.0;
  xp1_idx_1 = (x1 - 627.0) * 0.000655522779416585 + -1.0;
  xp1_idx_2 = (x1 - -105928.0) * 8.43401437999452E-6 + -1.0;
  xp1_idx_3 = (x1 - 629.0) * 0.000655737704918033 + -1.0;

  //  Layer 1
  //  Sigmoid Symmetric Transfer Function
  //  Layer 2
  b[0] = 0.25814271665312372;
  b[1] = 1.5836453394265069;
  b[2] = -0.75098367862895066;
  for (k = 0; k < 5; k++) {
    b_b[k] = 2.0 / (std::exp(-2.0 * (a[k] + (((b_a[k] * xp1_idx_0 + b_a[k + 5] *
      xp1_idx_1) + b_a[k + 10] * xp1_idx_2) + b_a[k + 15] * xp1_idx_3))) + 1.0)
      - 1.0;
  }

  //  Output 1
  //  Map Minimum and Maximum Output Reverse-Processing Function
  for (k = 0; k < 3; k++) {
    xp1_idx_0 = 0.0;
    for (int i = 0; i < 5; i++) {
      xp1_idx_0 += c_a[k + 3 * i] * b_b[i];
    }

    xp1_idx_0 = ((b[k] + xp1_idx_0) - -1.0) / dv[k];
    b[k] = xp1_idx_0;
    xp1_idx_0 += dv1[k];
    b_y1[k] = xp1_idx_0;
  }
}

//
// File trailer for myNeuralNetworkFunction.cpp
//
// [EOF]
//
